{"ast":null,"code":"import { takeEvery, call, put } from 'redux-saga/effects'; // importaremos efectos que nos permiten hacer cosas similares a yield en los generadores de funciones (function*)\n//importamos los efectos takeEvery, take, takeLast para captar el action en el SAGA.\n//importamos call, que es ejecutar un metodo dentro del SAGA, y no tener problemas de asincronía. En lugar de ejecutar una función asincrona directamente 'función', la ejecutamos con yield call(funcion)\n//importamos put, es el efecto de Saga que permite hacer dispatch a un action.\n// queremos dar funcionalidad que existe con thunk y las funciones que intercepta del archivo shop.actions.\n\nimport { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; //importamos las funciones de firebase, para acceder a backend.\n\nimport ShopActionTypes from './shop.types'; //importamos las Actions, para que se puedan ejecutar dentro de los sagas, y se puedan pasar los payloads al reducer.\n\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop.actions';\nexport function* fetchCollectionsAsync() {\n  try {\n    const collectionRef = firestore.collection('collections');\n    const snapShot = yield collectionRef.get(); //    const collectionMap = convertCollectionsSnapshotToMap(SnapShot); // se podría hacer así perfectamente, pero se utilizará call. Un efecto de la librería Saga. Es mejor, por si acaso, la llamada tarda mas de lo normal, y así esperamos a que se cargue igualmente, haciendo un yield.\n\n    const collectionMap = yield call(convertCollectionsSnapshotToMap, snapShot);\n    yield put(fetchCollectionsSuccess(collectionMap));\n  } catch (err) {\n    yield put(fetchCollectionsFailure(err));\n  }\n} // la segunda función fetchCollectionAsync puede tener control de que ejecutar. Yield ejerce el poder de pausar, y poder determinar que hacer.\n// la primera función, captará si el action es FETCH_COLLECTIONS_START. si existen mas sagas, en otros archivos, al ser asyncrono, no bloqueará la aplicación, y se podrán ejecutar todos a la vez. La segunda función generadora que se pasa como segundo parametro de take, también será una generación de función, que tiene funcionalidades similares a async/await\n\nexport function* fetchCollectionsStart() {\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n} //estos sagas serán exportados a un root-saga, y este a su vez, será exportado al store, mediante un import, se podrán configurar el middleware para que escuche las actions el saga.","map":{"version":3,"sources":["/home/pdrclv/react/crwn-clothing/src/redux/shop/shop.sagas.js"],"names":["takeEvery","call","put","firestore","convertCollectionsSnapshotToMap","ShopActionTypes","fetchCollectionsSuccess","fetchCollectionsFailure","fetchCollectionsAsync","collectionRef","collection","snapShot","get","collectionMap","err","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,IAApB,EAA0BC,GAA1B,QAAoC,oBAApC,C,CACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,EAAmBC,+BAAnB,QAA0D,+BAA1D,C,CACA;;AACA,OAAOC,eAAP,MAA4B,cAA5B,C,CACA;;AACA,SAASC,uBAAT,EAAkCC,uBAAlC,QAAgE,gBAAhE;AAEA,OAAO,UAAUC,qBAAV,GAAkC;AACvC,MAAG;AACD,UAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAFC,CAGL;;AACI,UAAMC,aAAa,GAAG,MAAMZ,IAAI,CAACG,+BAAD,EAAkCO,QAAlC,CAAhC;AACA,UAAMT,GAAG,CAACI,uBAAuB,CAACO,aAAD,CAAxB,CAAT;AACD,GAND,CAMC,OAAOC,GAAP,EAAW;AACV,UAAMZ,GAAG,CAACK,uBAAuB,CAACO,GAAD,CAAxB,CAAT;AACD;AACF,C,CACD;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACvC,QAAMf,SAAS,CAACK,eAAe,CAACW,uBAAjB,EAA0CR,qBAA1C,CAAf;AACD,C,CAED","sourcesContent":["import { takeEvery, call, put} from 'redux-saga/effects';\n// importaremos efectos que nos permiten hacer cosas similares a yield en los generadores de funciones (function*)\n//importamos los efectos takeEvery, take, takeLast para captar el action en el SAGA.\n//importamos call, que es ejecutar un metodo dentro del SAGA, y no tener problemas de asincronía. En lugar de ejecutar una función asincrona directamente 'función', la ejecutamos con yield call(funcion)\n//importamos put, es el efecto de Saga que permite hacer dispatch a un action.\n// queremos dar funcionalidad que existe con thunk y las funciones que intercepta del archivo shop.actions.\nimport { firestore,convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils';\n//importamos las funciones de firebase, para acceder a backend.\nimport ShopActionTypes from './shop.types';\n//importamos las Actions, para que se puedan ejecutar dentro de los sagas, y se puedan pasar los payloads al reducer.\nimport { fetchCollectionsSuccess, fetchCollectionsFailure} from './shop.actions';\n\nexport function* fetchCollectionsAsync() {\n  try{\n    const collectionRef = firestore.collection('collections');\n    const snapShot = yield collectionRef.get();\n//    const collectionMap = convertCollectionsSnapshotToMap(SnapShot); // se podría hacer así perfectamente, pero se utilizará call. Un efecto de la librería Saga. Es mejor, por si acaso, la llamada tarda mas de lo normal, y así esperamos a que se cargue igualmente, haciendo un yield.\n    const collectionMap = yield call(convertCollectionsSnapshotToMap, snapShot);\n    yield put(fetchCollectionsSuccess(collectionMap));\n  }catch (err){\n    yield put(fetchCollectionsFailure(err));\n  }\n}\n// la segunda función fetchCollectionAsync puede tener control de que ejecutar. Yield ejerce el poder de pausar, y poder determinar que hacer.\n// la primera función, captará si el action es FETCH_COLLECTIONS_START. si existen mas sagas, en otros archivos, al ser asyncrono, no bloqueará la aplicación, y se podrán ejecutar todos a la vez. La segunda función generadora que se pasa como segundo parametro de take, también será una generación de función, que tiene funcionalidades similares a async/await\nexport function* fetchCollectionsStart() {\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}\n\n//estos sagas serán exportados a un root-saga, y este a su vez, será exportado al store, mediante un import, se podrán configurar el middleware para que escuche las actions el saga.\n\n\n"]},"metadata":{},"sourceType":"module"}