{"ast":null,"code":"var _jsxFileName = \"/home/pdrclv/react/crwn-clothing/src/pages/shop/shop.component.jsx\";\nimport React from 'react';\nimport CollectionsOverview from '../../components/collections-overview/collections-overview.component';\nimport CollectionPage from '../collection/collection.component'; //hará falta firestore para poder conectarse a firebase.\n//import { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; // ya no hace falta al pasar la actividad asyncrona a redux con thunk\n//importamos la acción del shop redux updateCollections, que cargará en el redux las colleciones cargadas desde firebase. También importaremos connect, y así podremos hacer dispatch a redux\n\nimport { fetchCollectionsStartAsync } from '../../redux/shop/shop.actions';\nimport { connect } from 'react-redux';\nimport { createStructuredSelector } from 'reselect'; // para seleccionar y vincular los valores del state de redux.\n//ahora que shopPage está completamente desligado de props. Vamos a enrutarla, y añadirle rutas. \n\nimport { selectIsCollectionFetching } from '../../redux/shop/shop.selectors';\nimport { Route } from 'react-router-dom'; // importamos WithSpinner para envolver los componentes CollectionsOverview y CollectionsPage, hasta que se haya cargado el redux con los datos de firebase.\n\nimport WithSpinner from '../../components/with-spinner/with-spinner.component';\n/*  // forma primitiva, se llamaba así antes de incluir el listado shop en el state/store\nclass ShopPage extends React.Component{\n\tconstructor (props){\n\t\tsuper(props);\n\n\t\tthis.state = {collections:SHOP_DATA}\n\t}\n\n\trender(){\n\t\t//console.log(this.state); vemos que cargar this.state correctamente.\n\t\t// se pasa el valor this.state la variable {collections} brakets porque es objeto (D-structuring) a una variable collections, y se procesará cuando se llame al componente CollectionsPreview \n\t\tconst {collections} = this.state;\n\t\treturn (<div className='shop-page'>\n\t\t\t{collections.map(({id , ...otherCollectionsProps})=>(\n\t\t\t\t<CollectionPreview key={id} {...otherCollectionsProps} />\n\t\t\t))}\t\n\t\t</div>);\n\t}\n} */\n// creamos dos componentes que son simplemente collecionOverview y colletionPage, pero se envuelven en withSpinner, y así, según sea el state loading o no, se utilizará un componente withSpinner, o el componente normal.\n\nconst CollectionsOverviewWithSpinner = WithSpinner(CollectionsOverview);\nconst CollectionPageWithSpinner = WithSpinner(CollectionPage);\n\nclass ShopPage extends React.Component {\n  //se puede incluir en el reducer, de moment lo ponemos aquí, ya que sólo lo vamos a utlizar aquí de momento el estado loading.\n  //forma corta.\n  //\tstate={loading:true}; // ya no hace falta el state, puesto que se ha pasado la actividad asincrona al redux gracias a thunk\n  // cuando cargamos la aplicación, collections en redux necesita tiempo para cargar, y en ese periodo de tiempo, al cargar esta página, encuentra el error que la collection no está cargada, y el valor de collection es null, y nos da error.\n  //tenemos que envolver collectionsOverview y collectionsPage en un withSpinner. Se generará el state loading, y mientras esté en loading = true, se mostrará el spinner, y cuando sea false, se mostrará la página.\n  //aunque sea comprensible poner el WithSpinner en los componentes collections Overview y colletionsPage, se pondrá aquí, ya que es donde se carga la información de firebase, y se pasa a redux, y es donde se puede determinar si el estado loading es true o false.\n  // se hará fetch de la información de bakcend de collections en este componente, ya que es el componente padre de todos los hijos que utilizarán el redux del store del state collections.\n  // cuando el componente se monte, cargaremos desde el backend la información a redux.\n  // para empezar, se hace unsubscribe = null, para que cuando se desmonte el componente, rompa la conexión con el backend (con la referencia de firebase), y no ocupar memoria, ni que haya fuga de memoria \"memory leak\"\n  //\tunsubscribeFromSnapshot=null; //antes de estar la actividad asincrona en el redux, con thunk, se hacía de esta forma, ahora sólo se carga en component willmount con el selector de redux y suficiente, no hay que hacer unsubscribe.\n  componentDidMount() {\n    // tenemos que comenzar la actividad asincrona en el redux, enviandole fetchCollectionStartAsync()\n    //primer hace desesctructuración de las propiedades.\n    const fetchCollectionsStartAsync = this.props.fetchCollectionsStartAsync;\n    fetchCollectionsStartAsync();\n  }\n\n  render() {\n    // tenemos acceso a las propiedades match, porque viene de una página enroutada de Página principal.\n    // match.path tiene la información de la ruta donde está la página, y no hace falta escribirla manualmente. Así este componente es movible.\n    // hcemos una desestructuración de match en this.props, para que sea mas entendible cuando lo llamemos mas adelante.\n    const _this$props = this.props,\n          match = _this$props.match,\n          isCollectionFetching = _this$props.isCollectionFetching; //\t\tconst { loading } = this.state; // esto es de cuando se hacia la actividad asincrona en este componente, y no en el redux, ahora nos lo proporciona el redux.\n\n    return React.createElement(\"div\", {\n      className: \"shop-page\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 72\n      },\n      __self: this\n    }, React.createElement(Route, {\n      exact: true,\n      path: `${match.path}`,\n      render: props => React.createElement(CollectionsOverviewWithSpinner, Object.assign({\n        isLoading: isCollectionFetching\n      }, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 73\n        },\n        __self: this\n      })),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 73\n      },\n      __self: this\n    }), React.createElement(Route, {\n      path: `${match.path}/:collectionId`,\n      render: props => React.createElement(CollectionPageWithSpinner, Object.assign({\n        isLoading: isCollectionFetching\n      }, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 74\n        },\n        __self: this\n      })),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 74\n      },\n      __self: this\n    })); // inicialmente, antes de poner el spinner era simplemente poner component y el componente, ahora, con el spinner, se utiliza render, y es una función, que hay que pasarle los parametros match, para que puedan cargar el componente correcto collectionOverview o collectionPage\n    // <Route exact path={`${match.path}`} component={CollectionsOverview} />\n    // <Route path={`${match.path}/:collectionId`} component={CollectionPage} />\n  }\n\n}\n\nconst mapStateToProps = createStructuredSelector({\n  isCollectionFetching: selectIsCollectionFetching\n});\n\nconst mapDispatchToProps = dispatch => ({\n  fetchCollectionsStartAsync: () => dispatch(fetchCollectionsStartAsync())\n}); // ahora ya podemos utilizar el método updateCollections, haremos una desectructuración {updateCollections}=this.props\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ShopPage);","map":{"version":3,"sources":["/home/pdrclv/react/crwn-clothing/src/pages/shop/shop.component.jsx"],"names":["React","CollectionsOverview","CollectionPage","fetchCollectionsStartAsync","connect","createStructuredSelector","selectIsCollectionFetching","Route","WithSpinner","CollectionsOverviewWithSpinner","CollectionPageWithSpinner","ShopPage","Component","componentDidMount","props","render","match","isCollectionFetching","path","mapStateToProps","mapDispatchToProps","dispatch"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAOC,mBAAP,MAAgC,sEAAhC;AAEA,OAAOC,cAAP,MAA2B,oCAA3B,C,CACA;AACA;AACA;;AACA,SAASC,0BAAT,QAA2C,+BAA3C;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,wBAAT,QAAyC,UAAzC,C,CAAqD;AACrD;;AACA,SAASC,0BAAT,QAA2C,iCAA3C;AACA,SAASC,KAAT,QAAsB,kBAAtB,C,CACA;;AACA,OAAOC,WAAP,MAAwB,sDAAxB;AAGA;;;;;;;;;;;;;;;;;;;AAoBA;;AACA,MAAMC,8BAA8B,GAAGD,WAAW,CAACP,mBAAD,CAAlD;AACA,MAAMS,yBAAyB,GAAGF,WAAW,CAACN,cAAD,CAA7C;;AAEA,MAAMS,QAAN,SAAuBX,KAAK,CAACY,SAA7B,CAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAECC,EAAAA,iBAAiB,GAAE;AACpB;AACA;AAFoB,UAGXV,0BAHW,GAGoB,KAAKW,KAHzB,CAGXX,0BAHW;AAIlBA,IAAAA,0BAA0B;AAC1B;;AAEDY,EAAAA,MAAM,GAAE;AACT;AACA;AACA;AAHS,wBAI8B,KAAKD,KAJnC;AAAA,UAICE,KAJD,eAICA,KAJD;AAAA,UAIOC,oBAJP,eAIOA,oBAJP,EAKT;;AACE,WACC;AAAK,MAAA,SAAS,EAAC,WAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACC,oBAAC,KAAD;AAAO,MAAA,KAAK,MAAZ;AAAa,MAAA,IAAI,EAAG,GAAED,KAAK,CAACE,IAAK,EAAjC;AAAoC,MAAA,MAAM,EAAGJ,KAAK,IAAK,oBAAC,8BAAD;AAAgC,QAAA,SAAS,EAAEG;AAA3C,SAAqEH,KAArE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADD,EAEC,oBAAC,KAAD;AAAO,MAAA,IAAI,EAAG,GAAEE,KAAK,CAACE,IAAK,gBAA3B;AAA4C,MAAA,MAAM,EAAGJ,KAAK,IAAK,oBAAC,yBAAD;AAA2B,QAAA,SAAS,EAAEG;AAAtC,SAAgEH,KAAhE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAA/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFD,CADD,CANO,CAaT;AACA;AACA;AACE;;AAtCqC;;AAyCvC,MAAMK,eAAe,GAAGd,wBAAwB,CAAC;AAChDY,EAAAA,oBAAoB,EAAEX;AAD0B,CAAD,CAAhD;;AAIA,MAAMc,kBAAkB,GAAGC,QAAQ,KAAI;AACtClB,EAAAA,0BAA0B,EAAC,MAAMkB,QAAQ,CAAClB,0BAA0B,EAA3B;AADH,CAAJ,CAAnC,C,CAGA;;;AACA,eAAeC,OAAO,CAACe,eAAD,EAAiBC,kBAAjB,CAAP,CAA4CT,QAA5C,CAAf","sourcesContent":["import React from 'react';\n\nimport CollectionsOverview from '../../components/collections-overview/collections-overview.component';\n\nimport CollectionPage from '../collection/collection.component';\n//hará falta firestore para poder conectarse a firebase.\n//import { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; // ya no hace falta al pasar la actividad asyncrona a redux con thunk\n//importamos la acción del shop redux updateCollections, que cargará en el redux las colleciones cargadas desde firebase. También importaremos connect, y así podremos hacer dispatch a redux\nimport { fetchCollectionsStartAsync } from '../../redux/shop/shop.actions';\nimport { connect } from 'react-redux';\nimport { createStructuredSelector } from 'reselect'; // para seleccionar y vincular los valores del state de redux.\n//ahora que shopPage está completamente desligado de props. Vamos a enrutarla, y añadirle rutas. \nimport { selectIsCollectionFetching } from '../../redux/shop/shop.selectors';\nimport { Route } from 'react-router-dom';\n// importamos WithSpinner para envolver los componentes CollectionsOverview y CollectionsPage, hasta que se haya cargado el redux con los datos de firebase.\nimport WithSpinner from '../../components/with-spinner/with-spinner.component';\n\n\n/*  // forma primitiva, se llamaba así antes de incluir el listado shop en el state/store\nclass ShopPage extends React.Component{\n\tconstructor (props){\n\t\tsuper(props);\n\n\t\tthis.state = {collections:SHOP_DATA}\n\t}\n\n\trender(){\n\t\t//console.log(this.state); vemos que cargar this.state correctamente.\n\t\t// se pasa el valor this.state la variable {collections} brakets porque es objeto (D-structuring) a una variable collections, y se procesará cuando se llame al componente CollectionsPreview \n\t\tconst {collections} = this.state;\n\t\treturn (<div className='shop-page'>\n\t\t\t{collections.map(({id , ...otherCollectionsProps})=>(\n\t\t\t\t<CollectionPreview key={id} {...otherCollectionsProps} />\n\t\t\t))}\t\n\t\t</div>);\n\t}\n} */\n\n// creamos dos componentes que son simplemente collecionOverview y colletionPage, pero se envuelven en withSpinner, y así, según sea el state loading o no, se utilizará un componente withSpinner, o el componente normal.\nconst CollectionsOverviewWithSpinner = WithSpinner(CollectionsOverview);\nconst CollectionPageWithSpinner = WithSpinner(CollectionPage);\n\nclass ShopPage extends React.Component {\n//se puede incluir en el reducer, de moment lo ponemos aquí, ya que sólo lo vamos a utlizar aquí de momento el estado loading.\n//forma corta.\n//\tstate={loading:true}; // ya no hace falta el state, puesto que se ha pasado la actividad asincrona al redux gracias a thunk\n// cuando cargamos la aplicación, collections en redux necesita tiempo para cargar, y en ese periodo de tiempo, al cargar esta página, encuentra el error que la collection no está cargada, y el valor de collection es null, y nos da error.\n//tenemos que envolver collectionsOverview y collectionsPage en un withSpinner. Se generará el state loading, y mientras esté en loading = true, se mostrará el spinner, y cuando sea false, se mostrará la página.\n//aunque sea comprensible poner el WithSpinner en los componentes collections Overview y colletionsPage, se pondrá aquí, ya que es donde se carga la información de firebase, y se pasa a redux, y es donde se puede determinar si el estado loading es true o false.\n\n\n// se hará fetch de la información de bakcend de collections en este componente, ya que es el componente padre de todos los hijos que utilizarán el redux del store del state collections.\n// cuando el componente se monte, cargaremos desde el backend la información a redux.\n// para empezar, se hace unsubscribe = null, para que cuando se desmonte el componente, rompa la conexión con el backend (con la referencia de firebase), y no ocupar memoria, ni que haya fuga de memoria \"memory leak\"\n\n//\tunsubscribeFromSnapshot=null; //antes de estar la actividad asincrona en el redux, con thunk, se hacía de esta forma, ahora sólo se carga en component willmount con el selector de redux y suficiente, no hay que hacer unsubscribe.\n\n\tcomponentDidMount(){\n// tenemos que comenzar la actividad asincrona en el redux, enviandole fetchCollectionStartAsync()\n//primer hace desesctructuración de las propiedades.\n\t\tconst{ fetchCollectionsStartAsync } = this.props;\n\t\tfetchCollectionsStartAsync();\n\t}\n\n\trender(){\n// tenemos acceso a las propiedades match, porque viene de una página enroutada de Página principal.\n// match.path tiene la información de la ruta donde está la página, y no hace falta escribirla manualmente. Así este componente es movible.\n// hcemos una desestructuración de match en this.props, para que sea mas entendible cuando lo llamemos mas adelante.\n\t\tconst { match,isCollectionFetching }=this.props;\n//\t\tconst { loading } = this.state; // esto es de cuando se hacia la actividad asincrona en este componente, y no en el redux, ahora nos lo proporciona el redux.\n\t\treturn (\n\t\t\t<div className='shop-page'>\n\t\t\t\t<Route exact path={`${match.path}`} render={ props => (<CollectionsOverviewWithSpinner isLoading={isCollectionFetching} {...props} />)} />\n\t\t\t\t<Route path={`${match.path}/:collectionId`} render={ props => (<CollectionPageWithSpinner isLoading={isCollectionFetching} {...props} />)} />\n\t\t\n\t\t\t</div>\n\t\t);\n// inicialmente, antes de poner el spinner era simplemente poner component y el componente, ahora, con el spinner, se utiliza render, y es una función, que hay que pasarle los parametros match, para que puedan cargar el componente correcto collectionOverview o collectionPage\n// <Route exact path={`${match.path}`} component={CollectionsOverview} />\n// <Route path={`${match.path}/:collectionId`} component={CollectionPage} />\n\t}\n}\n\nconst mapStateToProps = createStructuredSelector({\n\tisCollectionFetching: selectIsCollectionFetching\n})\n\nconst mapDispatchToProps = dispatch =>({\n\tfetchCollectionsStartAsync:() => dispatch(fetchCollectionsStartAsync())\n})\n// ahora ya podemos utilizar el método updateCollections, haremos una desectructuración {updateCollections}=this.props\nexport default connect(mapStateToProps,mapDispatchToProps)(ShopPage);"]},"metadata":{},"sourceType":"module"}