{"ast":null,"code":"import _objectSpread from \"/home/pdrclv/react/crwn-clothing/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport 'firebase/auth';\nconst config = {\n  apiKey: \"AIzaSyC8jajl6VngHSsqroaGiCsmNGC53-7e00M\",\n  authDomain: \"crwn-db-71e6c.firebaseapp.com\",\n  databaseURL: \"https://crwn-db-71e6c.firebaseio.com\",\n  projectId: \"crwn-db-71e6c\",\n  storageBucket: \"crwn-db-71e6c.appspot.com\",\n  messagingSenderId: \"171761656914\",\n  appId: \"1:171761656914:web:d33aefd03fa33a9cf2eb8b\",\n  measurementId: \"G-6NMMPF19ST\"\n};\nfirebase.initializeApp(config);\nexport const createUserProfileDocument = async (userAuth, additionalData) => {\n  // si el usuario no está logeado o sign ineado, return, y no se sigue ejecutando nada mas.\n  if (!userAuth) return; // se le pasa el valor userAuth.uid como valor del documento, para ver si exite ese userRef, y se comprobará si existe ese uid en la colección users,  \n\n  const userRef = firestore.doc(`users/${userAuth.uid}`);\n  const snapShot = await userRef.get(); // snapShot tiene datos, y existe la propiedad exists es falso, se ejecutará el códdigo que hay dentro del if.\n\n  if (!snapShot.exists) {\n    const displayName = userAuth.displayName,\n          email = userAuth.email;\n    const createdAt = new Date();\n\n    try {\n      await userRef.set(_objectSpread({\n        displayName,\n        email,\n        createdAt\n      }, additionalData));\n    } catch (err) {\n      console.error('error creando usuario', err.message);\n    }\n  }\n\n  return userRef;\n}; // creamos una nueva función o utilidad de firebase para poder importar datos desde un objeto Json a una colleción con sus documentos en firebase.\n// si la función no tiene un await, no hace falta poner un async al generar la función delante de (collection,objectoToAdd)\n\nexport const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {\n  const collectionRef = firestore.collection(collectionKey); //creamos un batch, esto son transacciones, se pone dentro todo del batch, y al final se hace un commit, y nos aseguramos que se ejecuta el batch entero, y si algo falla, no se ejecuta nada.\n\n  const batch = firestore.batch(); // para cada elemento del objeto a añadir, se hace un forEach.\n\n  objectsToAdd.forEach(obj => {\n    const newDocRef = collectionRef.doc(); // al dejar doc() vacio, nos genera un id aleatorio\n\n    console.log(newDocRef); //ahora que tenemos el documento creado dentro de la colección, vamos a añadir el documento a la colección.\n    //aquí utilizaremos el batch creado antes. Para añadir el documento, los parametros son la dupla (documento,objeto)\n\n    batch.set(newDocRef, obj);\n  }); // batch es una promesa, hay que poner await delante de la función batch, y la función global hay que llamarla async\n\n  return await batch.commit();\n}; // esta función nos permitirá transformar el objeto obtenido de firebase en un objeto adaptado para nuestro redux, que tenga route y que tenga id el objeto de redux.\n\nexport const convertCollectionsSnapshotToMap = collections => {\n  //se creará una nueva colleción transformada, añadiendo route e id a title e items, que ya existe en cada documento\n  const transformedCollection = collections.docs.map(doc => {\n    //haciendo collections.docs obtenemos los documentos que hay en esa collection, y se hace un map para acceder doc a doc. En cada doc, se hace una desestructuración, y cogemos title e item, que es lo que necesitamos.\n    const _doc$data = doc.data(),\n          title = _doc$data.title,\n          items = _doc$data.items; // al hacer .data() a un doc, obtenemos el objeto que hay dentro de ese doc.\n\n\n    return {\n      // se utilizará el método endodeURI para que sea válido para enruta después en un URL\n      routeName: encodeURI(title.toLowerCase()),\n      id: doc.id,\n      // id no lo obtenemos en doc.data(), necesitamos obtenerlo desde el doc.id. Es el id de cada documento incluido en la colección 'collections'\n      title,\n      items\n    };\n  }); // para comprobar que el transfromedCollection es correcto  console.log(transformedCollection); pero esto es un array, no es el objeto que necesitamos que tenga los datos normalizados y sea fácil llamar desde el selector de redux\n  // ahora utilizando la función reduce, vamos a obtener el objeto que sea {hats: ..., sneackers:...., ....}\n  // transformedCollection.reduce se le pasa dos parametros, primero la función que tiene un accumulator, y segundo el valor inicial a cada iteración, que será un objeto vacio.\n\n  return transformedCollection.reduce((accumulator, docCollection) => {\n    //la función con el accumulator hará que se cree un array, en la que los documentos de la colleción serán los elementos, y cada key de cada elemento será el title, que a su vez se pondrá el tolowerCase.\n    accumulator[docCollection.title.toLowerCase()] = docCollection; // devuelve este nuevo elemento del objeto, y así hasta hacer todos los elementos de la colleción.\n\n    return accumulator;\n  }, {});\n}; //función para añadir item añadido al carrito del usuario que está logueado en Firebase\n//getUserCartRef devuelve la referencia de la colleción cart, donde se guardan los items por usuario.\n\nexport const getUserCartRef = async userId => {\n  //primero se obtiene un snapShot de la colección carts, y se ve si existe dentro de todos sus docs, un doc que tenga userId igual al que se le pasa.\n  const cartRef = firestore.collection('carts').where('userId', '==', userId);\n  const snapShot = await cartRef.get(); //si no existe un doc con el userId que le pasamos, crearemos un nuevo doc, que tenga userId, pero cartItems está inicializado a un array vacio.\n\n  if (snapShot.empty) {\n    const cartDocRef = firestore.collection('carts').doc();\n    await cartDocRef.set({\n      userId,\n      cartItems: []\n    });\n    return cartDocRef;\n  } else {\n    //si existe el userId, se devolverá el docRef que tiene ese userId y su array con los cartItems añadidos.\n    return snapShot.id;\n  }\n\n  ;\n}; //haremos una comprobación de si existe usuario logueado al cargar la página, o al hacer refresh, para que haya persistencia de usuario logueado.\n\nexport const getCurrentUser = () => {\n  return new Promise((resolve, reject) => {\n    // es una promesa, que captará el saga y se hará yield, que es como un async/await, enseguida detectaremos si hay un user autenticado, si lo hay haremos inmediatamente unsubscribe, y la promesa resolverá el usuario que hay    \n    const unsubscribe = auth.onAuthStateChanged(userAuth => {\n      unsubscribe();\n      resolve(userAuth);\n    }, reject);\n  });\n};\nexport const auth = firebase.auth();\nexport const firestore = firebase.firestore(); // exportaremos todas estas funcionaes al userSaga, que es donde se hará la actividad asincrona.\n\nexport const googleProvider = new firebase.auth.GoogleAuthProvider();\ngoogleProvider.setCustomParameters({\n  prompt: 'select_account'\n}); //export const signInWithGoogle = () => auth.signInWithPopup(provider); // ahora se ejecutará la función sigInWithPopup en userSaga\n\nexport default firebase;","map":{"version":3,"sources":["/home/pdrclv/react/crwn-clothing/client/src/firebase/firebase.utils.js"],"names":["firebase","config","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","measurementId","initializeApp","createUserProfileDocument","userAuth","additionalData","userRef","firestore","doc","uid","snapShot","get","exists","displayName","email","createdAt","Date","set","err","console","error","message","addCollectionAndDocuments","collectionKey","objectsToAdd","collectionRef","collection","batch","forEach","obj","newDocRef","log","commit","convertCollectionsSnapshotToMap","collections","transformedCollection","docs","map","data","title","items","routeName","encodeURI","toLowerCase","id","reduce","accumulator","docCollection","getUserCartRef","userId","cartRef","where","empty","cartDocRef","cartItems","getCurrentUser","Promise","resolve","reject","unsubscribe","auth","onAuthStateChanged","googleProvider","GoogleAuthProvider","setCustomParameters","prompt"],"mappings":"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","sourcesContent":["import firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport 'firebase/auth';\n\nconst config = {\n  apiKey: \"AIzaSyC8jajl6VngHSsqroaGiCsmNGC53-7e00M\",\n  authDomain: \"crwn-db-71e6c.firebaseapp.com\",\n  databaseURL: \"https://crwn-db-71e6c.firebaseio.com\",\n  projectId: \"crwn-db-71e6c\",\n  storageBucket: \"crwn-db-71e6c.appspot.com\",\n  messagingSenderId: \"171761656914\",\n  appId: \"1:171761656914:web:d33aefd03fa33a9cf2eb8b\",\n  measurementId: \"G-6NMMPF19ST\"\n};\n\nfirebase.initializeApp(config);\n\nexport const createUserProfileDocument = async (userAuth,additionalData) => {\n// si el usuario no está logeado o sign ineado, return, y no se sigue ejecutando nada mas.\n  if (!userAuth) return;\n// se le pasa el valor userAuth.uid como valor del documento, para ver si exite ese userRef, y se comprobará si existe ese uid en la colección users,  \n  const userRef = firestore.doc(`users/${userAuth.uid}`);\n  \n  const snapShot= await userRef.get();\n// snapShot tiene datos, y existe la propiedad exists es falso, se ejecutará el códdigo que hay dentro del if.\n  if (!snapShot.exists) {\n    const {displayName, email} = userAuth;\n    const createdAt = new Date();\n\n    try {\n      await userRef.set({\n        displayName,\n        email,\n        createdAt,\n        ...additionalData\n      })\n    } catch (err) {\n      console.error('error creando usuario',err.message);\n    }\n  }\n\n  return userRef;\n\n};\n\n// creamos una nueva función o utilidad de firebase para poder importar datos desde un objeto Json a una colleción con sus documentos en firebase.\n// si la función no tiene un await, no hace falta poner un async al generar la función delante de (collection,objectoToAdd)\nexport const addCollectionAndDocuments = async (collectionKey,objectsToAdd) => {\n  const collectionRef = firestore.collection(collectionKey);\n//creamos un batch, esto son transacciones, se pone dentro todo del batch, y al final se hace un commit, y nos aseguramos que se ejecuta el batch entero, y si algo falla, no se ejecuta nada.\n  const batch = firestore.batch();\n// para cada elemento del objeto a añadir, se hace un forEach.\n  objectsToAdd.forEach(obj => {\n    const newDocRef = collectionRef.doc(); // al dejar doc() vacio, nos genera un id aleatorio\n    console.log(newDocRef);\n//ahora que tenemos el documento creado dentro de la colección, vamos a añadir el documento a la colección.\n//aquí utilizaremos el batch creado antes. Para añadir el documento, los parametros son la dupla (documento,objeto)\n    batch.set(newDocRef,obj);\n  });\n// batch es una promesa, hay que poner await delante de la función batch, y la función global hay que llamarla async\n  return await batch.commit();\n};\n// esta función nos permitirá transformar el objeto obtenido de firebase en un objeto adaptado para nuestro redux, que tenga route y que tenga id el objeto de redux.\n\nexport const convertCollectionsSnapshotToMap = (collections) =>{\n//se creará una nueva colleción transformada, añadiendo route e id a title e items, que ya existe en cada documento\n  const transformedCollection = collections.docs.map(doc=>{\n//haciendo collections.docs obtenemos los documentos que hay en esa collection, y se hace un map para acceder doc a doc. En cada doc, se hace una desestructuración, y cogemos title e item, que es lo que necesitamos.\n    const {title,items} = doc.data();\n// al hacer .data() a un doc, obtenemos el objeto que hay dentro de ese doc.\n    return {\n// se utilizará el método endodeURI para que sea válido para enruta después en un URL\n      routeName:encodeURI(title.toLowerCase()),\n      id: doc.id,\n// id no lo obtenemos en doc.data(), necesitamos obtenerlo desde el doc.id. Es el id de cada documento incluido en la colección 'collections'\n      title,\n      items\n    }\n  });\n\n// para comprobar que el transfromedCollection es correcto  console.log(transformedCollection); pero esto es un array, no es el objeto que necesitamos que tenga los datos normalizados y sea fácil llamar desde el selector de redux\n// ahora utilizando la función reduce, vamos a obtener el objeto que sea {hats: ..., sneackers:...., ....}\n// transformedCollection.reduce se le pasa dos parametros, primero la función que tiene un accumulator, y segundo el valor inicial a cada iteración, que será un objeto vacio.\n\n  return transformedCollection.reduce((accumulator,docCollection) => {\n//la función con el accumulator hará que se cree un array, en la que los documentos de la colleción serán los elementos, y cada key de cada elemento será el title, que a su vez se pondrá el tolowerCase.\n    accumulator[docCollection.title.toLowerCase()]=docCollection;\n// devuelve este nuevo elemento del objeto, y así hasta hacer todos los elementos de la colleción.\n    return accumulator;\n  },{});\n\n};\n//función para añadir item añadido al carrito del usuario que está logueado en Firebase\n//getUserCartRef devuelve la referencia de la colleción cart, donde se guardan los items por usuario.\nexport const getUserCartRef = async userId=>{\n//primero se obtiene un snapShot de la colección carts, y se ve si existe dentro de todos sus docs, un doc que tenga userId igual al que se le pasa.\n  const cartRef=firestore.collection('carts').where('userId', '==', userId);\n  const snapShot = await cartRef.get();\n//si no existe un doc con el userId que le pasamos, crearemos un nuevo doc, que tenga userId, pero cartItems está inicializado a un array vacio.\n  if (snapShot.empty) {\n    const cartDocRef = firestore.collection('carts').doc();\n    await cartDocRef.set({userId,cartItems:[]});\n    return cartDocRef;\n  } else {\n//si existe el userId, se devolverá el docRef que tiene ese userId y su array con los cartItems añadidos.\n    return snapShot.id\n  };\n};\n\n//haremos una comprobación de si existe usuario logueado al cargar la página, o al hacer refresh, para que haya persistencia de usuario logueado.\n\nexport const getCurrentUser = () => {\n  return new Promise((resolve,reject) => {\n// es una promesa, que captará el saga y se hará yield, que es como un async/await, enseguida detectaremos si hay un user autenticado, si lo hay haremos inmediatamente unsubscribe, y la promesa resolverá el usuario que hay    \n    const unsubscribe=auth.onAuthStateChanged(userAuth =>{\n      unsubscribe();\n      resolve(userAuth);\n    },reject);\n  });\n}\n\nexport const auth = firebase.auth();\nexport const firestore = firebase.firestore();\n// exportaremos todas estas funcionaes al userSaga, que es donde se hará la actividad asincrona.\nexport const googleProvider = new firebase.auth.GoogleAuthProvider();\ngoogleProvider.setCustomParameters({ prompt:'select_account' });\n//export const signInWithGoogle = () => auth.signInWithPopup(provider); // ahora se ejecutará la función sigInWithPopup en userSaga\n\nexport default firebase;"]},"metadata":{},"sourceType":"module"}