{"ast":null,"code":"import ShopActionTypes from './shop.types';\nimport { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils';\nexport const fetchCollectionsStart = () => ({\n  type: ShopActionTypes.FETCH_COLLECTIONS_START\n}); //esta action no tiene payload. Sólo cambia el stado de redux a isloading.\n\nexport const fetchCollectionsSuccess = collectionsMap => ({\n  type: ShopActionTypes.FETCH_COLLECTIONS_SUCCESS,\n  payload: collectionsMap\n});\nexport const fetchCollectionsFailure = errorMsg => ({\n  type: ShopActionTypes.FETCH_COLLECTIONS_FAILURE,\n  payload: errorMsg\n}); //thunk es un actioncreator que nos devuelve una función dispatch en las acciones, y el resultado seguira siendo un objeto\n//en vez de crear un action que devuelve un objeto, vamos a crear una acción que devolverá una función que haremos dispatch, y el dispatch será llamado en varias acciones.\n\nexport const fetchCollectionsStartAsync = () => {\n  return dispatch => {\n    const collectionRef = firestore.collection('collections'); //aquí el truco es enviar en el dispatch fetchCollectionsStart, y así isLoading se cambiará a true. Gracias a que existe thunk.\n\n    dispatch(fetchCollectionsStart()); // onSnapshot es una subscripción al backend, propia de firebase, es un listener, que cada vez que hay un Snapshot, ejecuta el código que hay dentro de la función, podemos hacer una subscripción nativa, no propia de firebase con un Collection.set().then(ejecutar la función aquí) \"porque es una promesa ponemos then\", pero no será un listener, sólo se ejecutará una vez, cuando se haga montaje del componente. Lo dejaremos en la segunda opción, la subscripción de onSnapshot la dejo comentada.\n    //\t\t\tcollectionRef.onSnapshot(async snapshot => {\n\n    collectionRef.get().then(snapshot => {\n      const collectionToMap = convertCollectionsSnapshotToMap(snapshot); // console.log(collectionToMap); para comprobar que es el objeto correcto que queremos guradar en redux, ahora vamos a ver como lo guardamos. Generaremos un action, y después haremos un dispatch a redux.\n      //updateCollections(collectionToMap);\n      //cuando ya se ha cargado la información de firebase, y se ha pasado a redux la información del state, ya sabemos que el estado loading se puede poner a false, y se puede renderizar toda la página.\n\n      dispatch(fetchCollectionsSuccess(collectionToMap));\n    }).catch(err => dispatch(fetchCollectionsFailure(err.message)));\n  };\n};","map":{"version":3,"sources":["/home/pdrclv/react/crwn-clothing/src/redux/shop/shop.actions.js"],"names":["ShopActionTypes","firestore","convertCollectionsSnapshotToMap","fetchCollectionsStart","type","FETCH_COLLECTIONS_START","fetchCollectionsSuccess","collectionsMap","FETCH_COLLECTIONS_SUCCESS","payload","fetchCollectionsFailure","errorMsg","FETCH_COLLECTIONS_FAILURE","fetchCollectionsStartAsync","dispatch","collectionRef","collection","get","then","snapshot","collectionToMap","catch","err","message"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,cAA5B;AAEA,SAASC,SAAT,EAAmBC,+BAAnB,QAA0D,+BAA1D;AAEA,OAAO,MAAMC,qBAAqB,GAAG,OAAO;AAC1CC,EAAAA,IAAI,EAAEJ,eAAe,CAACK;AADoB,CAAP,CAA9B,C,CAGP;;AAEA,OAAO,MAAMC,uBAAuB,GAAGC,cAAc,KAAK;AACxDH,EAAAA,IAAI,EAAEJ,eAAe,CAACQ,yBADkC;AAExDC,EAAAA,OAAO,EAACF;AAFgD,CAAL,CAA9C;AAKP,OAAO,MAAMG,uBAAuB,GAAGC,QAAQ,KAAK;AAClDP,EAAAA,IAAI,EAAEJ,eAAe,CAACY,yBAD4B;AAElDH,EAAAA,OAAO,EAACE;AAF0C,CAAL,CAAxC,C,CAKP;AACA;;AACA,OAAO,MAAME,0BAA0B,GAAG,MAAM;AAC9C,SAAOC,QAAQ,IAAI;AACjB,UAAMC,aAAa,GAACd,SAAS,CAACe,UAAV,CAAqB,aAArB,CAApB,CADiB,CAErB;;AACIF,IAAAA,QAAQ,CAACX,qBAAqB,EAAtB,CAAR,CAHiB,CAIjB;AAEA;;AACIY,IAAAA,aAAa,CAACE,GAAd,GAAoBC,IAApB,CAA0BC,QAAQ,IAAI;AACpC,YAAMC,eAAe,GAAElB,+BAA+B,CAACiB,QAAD,CAAtD,CADoC,CAE1C;AACM;AACN;;AACML,MAAAA,QAAQ,CAACR,uBAAuB,CAACc,eAAD,CAAxB,CAAR;AACD,KAND,EAMGC,KANH,CAMSC,GAAG,IAAIR,QAAQ,CAACJ,uBAAuB,CAACY,GAAG,CAACC,OAAL,CAAxB,CANxB;AAOL,GAdD;AAeD,CAhBM","sourcesContent":["import ShopActionTypes from './shop.types';\n\nimport { firestore,convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils';\n\nexport const fetchCollectionsStart = () => ({\n  type: ShopActionTypes.FETCH_COLLECTIONS_START\n});\n//esta action no tiene payload. Sólo cambia el stado de redux a isloading.\n\nexport const fetchCollectionsSuccess = collectionsMap => ({\n  type: ShopActionTypes.FETCH_COLLECTIONS_SUCCESS,\n  payload:collectionsMap\n});\n\nexport const fetchCollectionsFailure = errorMsg => ({\n  type: ShopActionTypes.FETCH_COLLECTIONS_FAILURE,\n  payload:errorMsg\n})\n\n//thunk es un actioncreator que nos devuelve una función dispatch en las acciones, y el resultado seguira siendo un objeto\n//en vez de crear un action que devuelve un objeto, vamos a crear una acción que devolverá una función que haremos dispatch, y el dispatch será llamado en varias acciones.\nexport const fetchCollectionsStartAsync = () => {\n  return dispatch => {\n    const collectionRef=firestore.collection('collections');\n//aquí el truco es enviar en el dispatch fetchCollectionsStart, y así isLoading se cambiará a true. Gracias a que existe thunk.\n    dispatch(fetchCollectionsStart());\n    // onSnapshot es una subscripción al backend, propia de firebase, es un listener, que cada vez que hay un Snapshot, ejecuta el código que hay dentro de la función, podemos hacer una subscripción nativa, no propia de firebase con un Collection.set().then(ejecutar la función aquí) \"porque es una promesa ponemos then\", pero no será un listener, sólo se ejecutará una vez, cuando se haga montaje del componente. Lo dejaremos en la segunda opción, la subscripción de onSnapshot la dejo comentada.\n\n    //\t\t\tcollectionRef.onSnapshot(async snapshot => {\n        collectionRef.get().then( snapshot => {\t\n          const collectionToMap= convertCollectionsSnapshotToMap(snapshot);\n    // console.log(collectionToMap); para comprobar que es el objeto correcto que queremos guradar en redux, ahora vamos a ver como lo guardamos. Generaremos un action, y después haremos un dispatch a redux.\n          //updateCollections(collectionToMap);\n    //cuando ya se ha cargado la información de firebase, y se ha pasado a redux la información del state, ya sabemos que el estado loading se puede poner a false, y se puede renderizar toda la página.\n          dispatch(fetchCollectionsSuccess(collectionToMap));\n        }).catch(err => dispatch(fetchCollectionsFailure(err.message)));\n  }\n}\n\n\n\n"]},"metadata":{},"sourceType":"module"}