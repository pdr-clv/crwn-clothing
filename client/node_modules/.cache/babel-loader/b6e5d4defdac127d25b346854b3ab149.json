{"ast":null,"code":"import { takeEvery } from 'redux-saga/effects'; // importaremos efectos que nos permiten hacer cosas similares a yield en los generadores de funciones (function*)\n// queremos dar funcionalidad que existe con thunk y las funciones que intercepta del archivo shop.actions.\n\nimport { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; //importamos las funciones de firebase, para acceder a backend.\n\nimport ShopActionTypes from './shop.types'; //importamos las Actions, para que se puedan ejecutar dentro de los sagas, y se puedan pasar los payloads al reducer.\n\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop.actions';\nexport function* fetchCollectionsAsync() {\n  //  yield console.log('I am fired');\n  try {\n    const collectionRef = firestore.collection('collections');\n    const SnapShot = yield collectionRef.get();\n    const collectionMap = convertCollectionsSnapshotToMap(SnapShot);\n    fetchCollectionsStart(collectionMap);\n  } catch {}\n} // la segunda función fetchCollectionAsync puede tener control de que ejecutar. Yield ejerce el poder de pausar, y poder determinar que hacer.\n// la primera función, captará si el action es FETCH_COLLECTIONS_START. si existen mas sagas, en otros archivos, al ser asyncrono, no bloqueará la aplicación, y se podrán ejecutar todos a la vez. La segunda función generadora que se pasa como segundo parametro de take, también será una generación de función, que tiene funcionalidades similares a async/await\n\nexport function* fetchCollectionsStart() {\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n} //estos sagas serán exportados a un root-saga, y este a su vez, será exportado al store, mediante un import, se podrán configurar el middleware para que escuche las actions el saga.","map":{"version":3,"sources":["/home/pdrclv/react/crwn-clothing/src/redux/shop/shop.sagas.js"],"names":["takeEvery","firestore","convertCollectionsSnapshotToMap","ShopActionTypes","fetchCollectionsSuccess","fetchCollectionsFailure","fetchCollectionsAsync","collectionRef","collection","SnapShot","get","collectionMap","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA,SAASA,SAAT,QAA2B,oBAA3B,C,CACA;AACA;;AACA,SAASC,SAAT,EAAmBC,+BAAnB,QAA0D,+BAA1D,C,CACA;;AACA,OAAOC,eAAP,MAA4B,cAA5B,C,CACA;;AACA,SAASC,uBAAT,EAAkCC,uBAAlC,QAAgE,gBAAhE;AAEA,OAAO,UAAUC,qBAAV,GAAkC;AACzC;AACE,MAAG;AACD,UAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB;AACA,UAAMC,aAAa,GAAGT,+BAA+B,CAACO,QAAD,CAArD;AACAG,IAAAA,qBAAqB,CAACD,aAAD,CAArB;AACD,GALD,CAKC,MAAK,CAEL;AACF,C,CACD;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACvC,QAAMZ,SAAS,CAACG,eAAe,CAACU,uBAAjB,EAA0CP,qBAA1C,CAAf;AACD,C,CAED","sourcesContent":["import { takeEvery, } from 'redux-saga/effects';\n// importaremos efectos que nos permiten hacer cosas similares a yield en los generadores de funciones (function*)\n// queremos dar funcionalidad que existe con thunk y las funciones que intercepta del archivo shop.actions.\nimport { firestore,convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils';\n//importamos las funciones de firebase, para acceder a backend.\nimport ShopActionTypes from './shop.types';\n//importamos las Actions, para que se puedan ejecutar dentro de los sagas, y se puedan pasar los payloads al reducer.\nimport { fetchCollectionsSuccess, fetchCollectionsFailure} from './shop.actions';\n\nexport function* fetchCollectionsAsync() {\n//  yield console.log('I am fired');\n  try{\n    const collectionRef = firestore.collection('collections');\n    const SnapShot = yield collectionRef.get();\n    const collectionMap = convertCollectionsSnapshotToMap(SnapShot);\n    fetchCollectionsStart(collectionMap);\n  }catch{\n\n  }\n}\n// la segunda función fetchCollectionAsync puede tener control de que ejecutar. Yield ejerce el poder de pausar, y poder determinar que hacer.\n// la primera función, captará si el action es FETCH_COLLECTIONS_START. si existen mas sagas, en otros archivos, al ser asyncrono, no bloqueará la aplicación, y se podrán ejecutar todos a la vez. La segunda función generadora que se pasa como segundo parametro de take, también será una generación de función, que tiene funcionalidades similares a async/await\nexport function* fetchCollectionsStart() {\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}\n\n//estos sagas serán exportados a un root-saga, y este a su vez, será exportado al store, mediante un import, se podrán configurar el middleware para que escuche las actions el saga.\n\n\n"]},"metadata":{},"sourceType":"module"}